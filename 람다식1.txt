

람다식 


1.1 람다식 이전 프로그램 구현 방식

 람다식 이전의 구현하던 방식은 '명령형 스타일' 이라고 하고 , 람다식으로 구현한 방식을 '함수형 스타일'이라고 합니다.
명령형 스타일은 프로그램 구현 시 모든 작업 내용을 자바 코드로 자세하게 작성하는 방식이라 구현해야 할 코드양이 많습니다.
하지만 함수형 스타일은 개발자가 핵심 내용만 구현하고 나머지는 자바 언어에서 자동으로 처리하는 방식이어서 코드가 간결합니다.

결론적으로 람다식을 사용하면 이전 방식에 비해 구현코드를 간소화 할 수 있습니다.


(1) 명령형 스타일

  다음은 명령형 스타일로 구현한 간단한 코드입니다.

     List<String> list = Arrays.asList("서울 " ,"북경", "상해", "뉴욕");
      boolean result = false;
              for (String city : list) { 
                    //String city를 자동으로 배열의 크기(list)만큼  for 문을 돌려줍니다.

                   if(city.equals("서울")) {
                     result = true;
                     break;
                           }
                    }

                      System.out.println(result);




for 문을 이용해 list 에서 "서울"을 검색합니다.
"서울"을 발견하면 result 변수에 true를 저장하고 종료합니다.
result 변수는 검색결과를 저장하고자 선언한 변수입니다.






(2) 서술형 스타일 
 
 다음은 명령형 스타일의 코드를 서술형 스타일로 변경한 코드입니다.
 
  List<String> list = Arrays.asList("서울 " ,"북경", "상해", "뉴욕");
  System.out.println(list.contains("서울"));
  //contains( )메소드는 인자에 지정된 일련의 문자들을 포함하고 있으면 true값을 리턴합니다.


  list에서 제공하는 contatins( ) 메소드를 사용하고 있습니다.
 서술형 스타일은 명령형 스타일처럼 변수와 로직을 구현해서 실행하는 것이 아니라, 
 처리 로직이 구현된 메소드를 호출해서 처리합니다. 
 따라서 불필요한 작업이 생략되고 코드가 간결해져 유지보수가 편리합니다.



(3) 함수형 스타일

 함수형 스타일은 앞에서 살펴본 서술형 스타일에 객체의 개념과 명령문을 추가하여 처리하는 방식입니다.
 이 방식을 지원하는 핵심 기능이 바로 람다식입니다.
 람다식이 등장하게 된 배경을 알기 위해 인터페이스를 구현하는 방식을 살펴보겠습니다.



1.2 인터페이스 구현 방법

 이번 절에서는 명령형 스타일로 인터페이스를 구현하는 세 가지 방식에 대해 살펴보겠습니다.
 
 구현하고 싶은 인터페이스는 다음과 같습니다.


        Interface MyInterface {
            public void print( );
               }

 1.2.1 방법 1 : implements 키워드로 클래스 선언

 인터페이스를 구현하는 가장 일반적인 방법은 클래스를 선언할 때 ' implements 인터페이스명' 을 선언한 후 ,
 인터페이스에 선언된 추상 메소드를 오버라이딩하는 것입니다.

 class MyClass1 implements MyInterface {
            @Override
            public void print( ) {
              System.out.println("MyClass1");
             }
           }
        class MyClass2 implements MyInterface {
              @Override
              public void println("MyClass2");
           }
          }

 인터페이스에 선언된 메소드를 실행할 때는 인터페이스를 구현한 클래스의 인스턴스를 생성한 후 
참조변수를 이용해 호출합니다.

   MyClass m1 = new MyClass1( );
   MyClass m2 = new MyClass2( );
   m1.print( );
   m2.print( );



 
1.2.3 방법 2 : 익명 클래스 사용
 
 인터페이스를 구현하는 방법 중 하나는 익명 클래스를 사용하는 것입니다.
 익명 클래스로 인터페이스를 구현할 때는 클래스를 별도로 선언할 필요 없이 인터페이스 구현과 
 동시에 인스턴스를 생성할 수 있습니다.

 익명클래스로 인터페이스를 구현할 때 문법은 다음과 같습니다.
 
 【 익명클래스로 인터페이스 구현 】

 인터페이스명 변수명 = new 인터페이스명( ) {
  메소드 오버라이딩
   };

다음 코드는 익명클래스로 MyInterface를 구현하는 코드입니다.


  MyInterface mi = new Interface( ) {
   @Override
  public void print( ){
   System.out.println("익명 클래스로 구현") ;
  
 위의 코드는 MyInterface를 구현한 익명 클래스가 생성되고 mi 변수가 참조합니다.
 이때 , 익명 클래스는 이름이 없으므로 mi 변수의 타입은 인터페이스 타입으로 지정합니다.
 익명 클래스에서 구현된 print( ) 메소드를 호출할 때는 참조변수를 이용합니다.

 mi.print( );
   //출력문을 작성합니다.
 
 
 1.2.4 선언, 생성, 호출을 한번에 처리

 인터페이스를 구현하는 마지막 방법은 앞에서 살펴본 두개의 클래스와 익명클래스,참조변수가 필요없습니다.
 그 이유는 인터페이스 구현과 동시에 객체가 생성되고 메소드 호출이 실행되기 때문입니다.
  
 다음은 인터페이스를 구현하는 익명클래스의 선언 , 생성, 메소드 호출을 한번에 처리하는 문법입니다.

 【 익명클래스 선언, 생성 , 메소드 호출 】

 (new 인터페이스명( ) {
 메소드 오버라이딩 
 }).메소드명( );
 
 예제 코드는 다음과 같습니다.
  
 (new MyInterface( ) {
 @Override
 public void print( ) {
  System.out.println("선언 ,생성 ,호출을 한번에 처리");
 }
 }).print( );

 위 명령문이 실행되면 MyInterface 인터페이스의 print( ) 메소드를 구현한 익명 클래스가 생성되고 난 후,
 print( ) 메소드를 호출합니다.

 

 

 1.3 매개변수
 
 인터페이스 타입으로 매개변수가 선언된 경우를 살펴보겠습니다.
 다음의 test( ) 메소드는 MyInterface 타입으로 매개변수가 선언되어 있습니다.

 public static void test(MyInterface mi) {
  mi.print( );
 }
 
 test( )메소드 호출 시 인터페이스를 구현한 클래스의 참조변수 또는 익명 클래스의 참조 변수를 인자로 전달할 수 있습니다.
 
 다음의 예제 코드를 살펴보겠습니다.
 
 MyClass1 mc1 = new MyClass1( );
 MyClass2 mc2 = new MyClass2( );
 MyInterface mi = new MyInterface( ) {
 @Override
 public void print( ){
 System.out.println("익명클래스로 구현");
  }
 };
 test(mc1);  //구현방법 1
 test(mi); // 구현방법 2

 test ( ) 메소드가 실행된 결과는 다음과 같습니다.


 MyClass1
 익명클래스로 구현



 1.3.1 리턴 타입
 
 인터페이스 타입으로 반환값이 선언된 메소드를 살펴보겠습니다.
 다음의 test2( ) 메소드는 MyInterface 타입을 반환합니다.

 public static MyInterface test2( ) {
 MyInterface mi = new MyInterface( ){ 
 @Override
 public void print( ) {
  System.out.println("test2( ) 메소드에서 반환된 MyInterface");
   }
  };
 return mi;
  }
 
다음은 인터페이스를 반환하는 메소드를  호출하는 예제코드입니다.
 
 MyInterface mi2 =test2( );
 mi2.print( );

 mi2.print( ) 메소드가 실행되면 콘솔 창에 다음처럼 출력됩니다.

 --------실행결과----------
 test2( )메소드에서 반환된 MyInterface






 지금까지 설명한 내용에 대한 예제 코드는 다음과 같습니다.


  package com.ruby.java.ch14;

 interface MyInterface {
    public void print( );
       }
   
 class MyClass1 implements MyInterface {
 @Override
 public void print ( ){
    System.out.println("MyClass1");
  } 
}
  class Myclass2 implements MyInterface {
  @Override
 public void print( ){
 System.out.println("MyClass2");
 }
}
 
 public class Test01{
 public static void test(MyInterface mi) {
 mi.print( );
 }
 
 public static MyInterface test2( ) {
 MyInterface mi  = new MyInterface( ){
 @Override
 public void print( ) {
 System.out.println("test2( ) 메소드에서 반환된 MyInterface");
  }
 };
 return mi;
 }
 
 public static void main(String[] args) {
 
  MyClass mc1 = new MyClass1( );
  MyClass mc2 = new MyClass2( );
  mc1.print( ); //MyClass1
  mc2.print( ); //MyClass2

  MyInterface mi = new Interface( ) {
 @Override
  public void print( ) {
 System.out.println("익명클래스로 구현");
   }
  };

 test(mc1); //MyClass1
 test(mc2); //익명클래스로 구현

 mi.print( ); //익명클래스로 구현

(new MyInterface( ) {
 @Override
 public void print( ) {
 System.out.println("선언, 생성, 호출을 한번에 처리" );
 }
 }).print( );   //선언 , 생성 , 호출을 한번에 처리

 MyInterface mi2 = test2( );
 mi2.print( ); //test2( ) 메소드에서 반환된 MyInterface
 }
}


  ------------------실행결과----------------------
MyClass1
MyClass2
MyClass1
익명클래스로 구현
익명클래스로 구현
선언, 생성, 호출을 한번에 처리
test2( ) 메서드에서 반환되 MyInterface



2. 람다식 사용하기

 2.1 람다식 기본
  이번 절에서는 람다식을 사용해 인터페이스를 구현하고 생성한 후 사용하는 함수형 스타일로 코드를 작성하겠습니다.

 2.1.1 일반 인터페이스 구현

 다음 test3( ) 메소드는 MyInterface를 구현한 익명클래스를 생성해 반환합니다.

 public static MyInterface test3( ) {
 return new MyInterface( ) {
 @Override
 public void print( ) {
 System.out.println("hello");
    }
  });
 }


 test3( ) 메소드에서 반환한 익명 클래스를 사용하려면 다음처럼 test3( ) 메소드를 호출하고, 
반환되는 값을 저장합니다. 이 때 반환되는 익명클래스가 구현한 MyInterface 타입으로 참조변수를 선언한 후 
참조변수를 이용해 print( ) 메소드를 호출합니다.

 MyInterface m = test3( );
 m.print( );


 2.1.2 람다식 구현

  바로 앞에서 구현한 코드를 람다식으로 구현하면 다음과 같습니다.
 
664p 그림 스캔해서 첨부하기

 
 람다식에서는 test3( )과 같은 메소드 선언이 필요없습니다. 메소드의 매개변수들이 선언되는 괄호( )는 
그대로 표현하고, 인터페이스에 선언된 추상 메소드의 본문을 구현할 때는 화살표(->) 기호 다음에
작성합니다. 본문을 구현할 때 명령문이 한 줄이면 예와 같이 사용하고, 여러 줄일 때는 중괄호{ } 로 감싸줍니다.

 화살표 (->) 기호 다음에는 인터페이스에 선언된 추상 메소드의 본문을 구현한다고 했습니다. 
그런데 인터페이스에 선언된 추상메소드가 여러 개일 때는 어떤 메소드의 본문인지 구별할 방법이 없습니다.
따라서 람다식으로 구현하려는 인터페이스는 '반드시 하나의 메소드만 선언'되어야 합니다.
 
 그리고 메소드만 선언된 인터페이스를  "함수형 인터페이스" 라고 합니다. 정리하면 
람다식으로 구현할 수 있는 인터페이스는 함수형 인터페이스만 가능합니다.




 2.1.3 기본 문법
 
 람다식의 문법은 다음과 같습니다.

 【 람다식 】 
 ( ) -> 명령문;            // 함수형 인터페이스의 추상 메소드 구현 시 명령문이 한 개일 때
 ( ) -> {                    // 함수형 인터페이스의 추상 메소드 구현 시 명령문이 여러 개 일때
    명령문1;
    명령문2;
    명령문n;

  };
 



예제를 통해 자세하게 살펴보겠습니다.



package com.rubt.java.ch14;
 
 interface Multiply {
 double getValue( );
 }
 
 public class Test02 {
 
 public static void main(String[] args){
 
  Multiply m;
 m = ( ) -> 3.14 * 2;
 System.out.println( m.getValue( ));

 m= ( ) -> 10 *3 ;
  System.out.println(m.getValue( ));
     }
   }


----------실행 결과 -------------
 
6.28
30.3



소스에 대한 자세한 설명은 다음과 같습니다.


interface Multiply {
 double getValue( );
 } 

Multiply 라는 이름의인터페이스에 getValue( )라는 추상메소드를 하나 선언합니다. 이 메소드는 매개변수가 없고
double 타입의 값을 반환합니다. 이처럼 하나의 메소드만 선언된 인터페이스를 함수형 인터페이스라고 합니다.



Multiply m;

인터페이스 Multiply 타입을 참조하는 변수 m을 선언합니다.


 m = ( ) -> 3.14 * 2;

변수 m의 타입은 Multiply 인터페이스입니다.
 그리고 " = ( ) -> 3.14*2" 코드는 Multiply 인터페이스를 구현하는 람다식입니다.
Multiply 인터페이스에 선언된 메소드는 04번줄의 getValue( )입니다.
따라서 ( ) -> 3.14*2는 getValue( ) 메소드를 오버라이딩하는 코스입니다. 괄호 ( ) 안이 비어 있으므로
 인자값을 전달하지 않으며 3.14*2를 계산해 반환합니다.


 System.out.println( m.getValue( ));
 13번 줄에 있는 m.getValue는 12번 줄에서 구현한 메소드를 실행합니다.


  m= ( ) -> 10 *3 ;
 Multiply 인터페이스의 getValue( ) 메소드를 다시 오버라이딩합니다.
 10*3을 계산하여 반환합니다.


  System.out.println(m.getValue( ));

16번 줄에 있는 m.getValue( )는 15번 줄에서 구현한 메소드를 실행합니다.





2.1.4 @FunctionallyInterface 어노테이션

 람다식으로 구현할 수 있는 인터페이스는 하나의 추상 메소드를 포함하는 함수형 인터페이스만 가능합니다.
따라서 함수형 인터페이스를 작성할 때 , 두 개 이상의 추상 메소드가 선언되는 오류를 예방하고자
@FunctionallyInterface  어노테이션을 사용할 수 있습니다.
인터페이스 선언부 앞 줄에 @FunctionallyInterface  어노테이션을 지정하면 하나 이상의 추상 메소드가 선언될 때
다음 표시한 곳에 컴파일 오류가 발생합니다.

@FunctionallyInterface 
public interface 〔MyInterface〕 {
  public void put( );
  public void get( );
  }

 인터페이스를 선언할 때 @FunctionallyInterface 어노테이션은 지정은 필수가 아니라 선택입니다.
@FunctionallyInterface 를 지정하지 않아도 추상메소드를 한개만 선언했다면 함수형 인터페이스인 것입니다.
 @FunctionallyInterface 는 단지 인터페이스에 추상 메소드를 둘 이상 선언할 때 오류를 발생시켜줌으로써
 개발자가 함수형 인터페이스를 선언하려는 의도에 벗어나지 않도록 돕습니다.







2.1.5 람다식 매개변수 

 앞에서 선언한 함수형 인터페이스의 추상 메소드에는 매개변수가 없었습니다.
이번에는 매개변수가 있는 추상 메소드를 선언하였을 때 람다식으로 구현하는 방법을 알아봅니다.

 【 매개변수가 있는 람다식 구현 】

(변수명) -> 명령문;                                   // 매개변수가 한개일 때
(변수명1, 변수명2, .... 변수명 n) -> 명령문;    //매개변수가 여러 개일 때


 람다식으로 매개변수를 선언할 때는 괄호(  )안에 매개변수 갯수만큼 변수명을 지정합니다.
특이한 점은 변수명 앞에 타입을 지정하지 않는다는 것 입니다. 이처럼 변수의 타입을 지정하지 않으면 자바 언어에서
자동으로 인터페이스에 선언된 추상 메소드의 매개변수 타입으로 처리해주므로 생략해도 상관 없습니다.
이처럼 함수형 스타일은 개발자가 핵심적인 내용만 구현하고 부가적인 처리는 자바 언어에 맡기는 특징이 있습니다.

물론 괄호 (  ) 안에 타입을 지정하고 싶다면 다음처럼 할 수도 있습니다. 그러나 인터페이스의 메소드를 구현할 때
매개변수의 타입이 변경될 일은 없으므로 생략하는 것이 효율적입니다.

(타입 변수명) -> 명령문;
 
람다식에서 매개변수를 사용하는 예를 살펴보겠습니다. 다음의 Verify 인터페이스에 선언된 check( ) 메소드는
int n 매개변수가 선언되었습니다.
 

interface Verity {
 boolean check(int n);
 }

 다음 코드는  Verity 인터페이스의 check( )를 일반 메소드로 구현한 예입니다.

 public  boolean check(int n) {
    return (n % 2) = 0;
    }

 위와 같은 코드를 람다식으로 구현하면 다음과 같습니다.

  (n) -> (n % 2) = 0;

이번에는 매개변수가 두 개 있는 추상 메소드를 선언하는 예입니다.

 interface Verity2 {
  boolean check(int n , int d) {
    return (n % d) = 0;
   }

 위와 같은 코드를 람다식으로 구현하면 다음과 같습니다.
(n , d) -> (n % d) = 0;

 이처럼 람다식을 이용하면 구현코드가 줄어드는 효과를 확인할 수 있습니다.





※매개 변수를 한 개 사용하는 람다식 

다음은 한 개의 매개변수가 선언된 메소드를 구현하는 람다식 예제입니다.

 package com.ruby.java.ch14;
 
interface Verity {
 boolean check(int n);
 }
 
 public class Test03 {
  public static void main(String[] args) {
    Verity isEven = (n) -> ( n % 2 ) =0;
  
   System.out.println(isEven.check(10));


 
   Verity isPositive = (n) -> n >== 0;
 
   System.out.println(isPositive.check(-5));
  }
}


-------------실행 결과----------------------

true
false



소스에 대한 자세한 설명은 다음과 같습니다.

interface Verity {
 boolean check(int n);
 }


리턴타입은 boolean, 매개변수 타입은 int인 check( ) 메소드를 포함하는 함수형 인터페이스 Verity를 선언합니다.


  Verity isEven = (n) -> ( n % 2 ) ==0; 
  

   Verity 인터페이스의 check( )메소드를 구현한 후 isEven 변수가 해당 메소드를 참조하도록 하였습니다.
   (n) -> ( n % 2 ) ==0; 람다식을 일반 메소드로 표현하면 다음과 같습니다. 

  boolean check(int n) { 
   return ( n % 2) ==0;
   }

 
 매개변수로 전달받은 n을 2로 나눈 나머지가 0이면 true , 아니면 false를 반환합니다.

 System.out.println(isEven.check(10));
  
 isEven.check(10) 코드는 isEven이 참조하는 check( ) 메소드를 호출합니다. 즉 09번 줄에서 구현한 람다식을 실행합니다.
 이때 인자값으로 전달한 10은 매개변수 n에 전달됩니다.

669p 인자값 전달 그림 삽입

Verity isPositive = (n) -> n >== 0;

Verity 인터페이스의 check( ) 메소드를 람다식으로 구현한 후 isPositive 변수가 해당 메소드를 참조하도록 하였습니다.

 (n) -> n >== 0; 람다식을 일반 메소드로 표현하면 다음과 같습니다.
 
  boolean check(int n) {
   return n>=0;
  }

 매개변수로 전달받은 n이 0 이상이면 true 그렇지않으면 false를 반환합니다.


    System.out.println(isPositive.check(-5));
  
   isPositive.check(-5)코드는 isPositive가 참조하는 check( )메소드를 호출합니다. 즉 12번 줄에서 구혀한 람다식을 실행합니다.






※매개변수를 여러 개 사용하는 람다식 

다음은 여러 개의 매개변수가 선언된 메소드를 구현하는 람다식 예제입니다.

    package com.ruby.java.ch14;

 interface Verity2 {
   boolean check (int n, int b);
    }

 public class Test04 { 
    public static void main(String[] args) {
     Verity2 vf = (n , d) -> (n % d) ==0;
           System.out.println(vf.check(24.3));
             }
           }

 ---------실행 결과 -------------
true


 소스에 대한 자세한 설명은 다음과 같습니다.

      interface Verity2 {
         boolean check (int n, int b);
           }
  int, int 타입으로 매개변수가 선언된 check( ) 추상 메소드를 포함하는 함수형 인터페이스 Verity2를 
선언합니다.

  Verity2 vf = (n , d) -> (n % d) ==0; 
  
  Verity2 인터페이스의 check( )메소드를 구현한 람다식입니다. (n, d)는 check(int n , int d) 를 의미합니다.
 09번 줄을 익명클래스로 선언하면 다음과 같습니다.

 Verity2 vf = new Verity2( ) {
  public boolean check(int n , int d) {
  return (n % d ) ==0;
  }
}

 매개변수로 전달받은 n을 d로 나눈 나머지가 0이면 true, 그렇지 않으면 false 값을 반환합니다.

  System.out.println(vf.check(24.3));

 f.check(24.3)코드는 09번 줄에서 구현한 람다식을 실행합니다. 람다식의 n은 24 , d는 3 을 전달받습니다.








2.1.6 람다식 블록

 람다식 문법에서 ( )-> 기호 다음 부분은 람다식의 본문입니다.
람다식 본문의 명령문이 한 줄이면 다음처럼 표현하며 , 이때는 return문을 생략해도 명령문에서 처리된 값이 자동으로
반환됩니다.




【 람다식 본문이 한 줄일 때 】

( ) -> 명령문;

람다식 본문에 명령문을 여러 줄로 구현하려면 다음처럼 블록  { } 으로 감싸야합니다.


【 람다식 본문이 여러 줄일 때 】

( ) -> {
   명령문1;
    명령문2;
   return값 ;
  };


 이때 주의사항은 반환값이 있을 때는 반드시 return 문을 지정해야한다는 것입니다.
 람다식에서 return문은 명령문이 한 줄일 때는 생략해도 되지만 , 블록 {  }을 사용하면 생략할 수 없습니다.



 다음은 람다식 본문을 블록으로 처리하는 예제입니다.

package cm.ruby.java.ch14;

 interface NumberFunc {
   int func(int n);
    }
  public class Test05 {
    public static void main(String[] args) {
  NumberFunc sum = (n) -> {
    int result = 0;
    for(int i =0; i <=n; i++) {
      result += i;
      }
     return result;
     };

    System.out.println("1부터 10까지의 합 :  " + sum.func(10));
    System.out.println("1부터 100까지의 합 :  " + sum.func(100));
     }
   }




-------------실행 결과 -------------------------

1부터 10까지의 합 : 55
1부터 100까지의 합  : 5050








2.1.7 제네릭 함수형 인터페이스 

 다음 코드는 함수형 인터페이스를 선언합니다.


 interface StringFunc { 
     String modify(String s);
     }

  interface IntegerFunc  {
   Integer modify(Integer n);
   }

 

StringFunc와 IntegerFunc 인터페이스에 선언한 메소드의 공통점은 리턴타입과 매개변수의 타입이 같습니다.
이럴 때 제네릭 함수형 인터페이스로 선언하면 한 번의 인터페이스 선언으로 모든 타입을 인자로 받아 처리할 수 있습니다.

 다음은  StringFunc와 IntegerFunc 두 개의 인터페이스를 한번에 처리할 수 있는 제네릭 함수형 인터페이스입니다.

 
interface MyFunc<T> {
  T modify (T t );
    }

 제네릭 함수형 인터페이스에서 타입 매개변수 T에 전달하는 타입 인자는 람다식을 참조하는 참조변수에 지정해야합니다.
 람다식에서는 제네릭을 사용할 수 없습니다.
 
 다음은 제네릭 인터페이스에 타입 인자를 전달하는 문법입니다.


    【 제네릭 인터페이스에 타입 인자 전달 】
    인터페이스명<타입 인자> 변수명 = ( ) -> 명령문

 예제 코드는 다음과 같습니다.
 
 MyFunc<String> mf1 = (str) -> str.toUpperCase( ) + " : " + str.length( );
 MyFunc<Integer> mf2 = (n) -> n *2;

mf1의 람다식은 타입 인자를 String 으로 전달하고 mf2의 람다식은 타입 인자를 Integer로 전달합니다.

예제를 통해 자세히 살펴보겠습니다.


   package cm.ruby.java.ch14;
  
  interface MyFunc<T> {
  T modify(T t);
   }
  
  public class Test06 {

    public static void main(String[] args) { 

   MyFunc<String> mf1 = (str) -> str.toUpperCase( ) + " : " + str.length( );
     System.out.println(mf1.modify("java"));
      System.out.println(mf1.modify("java programming"));


   MyFunc<String> mf2 = (n) -> n *2 ;
     System.out.println(mf2.modify("23"));
      System.out.println(mf2.modify("42"));
       }
      }


-------------실행 결과 --------------------

java : 4
java programming  : 16
46
84


소스에 대한 자세한 설명은 다음과 같습니다.
 
 